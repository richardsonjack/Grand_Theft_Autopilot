#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from deepgtav.messages import Start, Stop, Dataset, frame2numpy, Scenario, Commands
from deepgtav.client import Client
from pathfind import *
from scipy.spatial import distance
import argparse
import time
import cv2
import GPS
import random
import math
from getkeys import key_check

class Model:
    lastCmd = [0,0,0]
    loc = (0, 0, 0)
    heading = 0
    pathLoc = 0
    arrived = False

    def __init__(self, g):
        self.gps = g


    def roi(img, vertices):
    
        #blank mask:
        mask = np.zeros_like(img)
                
        #filling pixels inside the polygon defined by "vertices" with the fill color    
        cv2.fillPoly(mask, vertices, 255)
        
        #returning the image only where mask pixels are nonzero
        masked = cv2.bitwise_and(img, mask)
        return masked


    def draw_lanes(img, lines, color=[0, 255, 255], thickness=3):

        # if this fails, go with some default line
        try:

            # finds the maximum y value for a lane marker 
            # (since we cannot assume the horizon will always be at the same point.)

            ys = []  
            for i in lines:
                for ii in i:
                    ys += [ii[1],ii[3]]
            min_y = min(ys)
            max_y = 600
            new_lines = []
            line_dict = {}

            for idx,i in enumerate(lines):
                for xyxy in i:
                    # These four lines:
                    # modified from http://stackoverflow.com/questions/21565994/method-to-return-the-equation-of-a-straight-line-given-two-points
                    # Used to calculate the definition of a line, given two sets of coords.
                    x_coords = (xyxy[0],xyxy[2])
                    y_coords = (xyxy[1],xyxy[3])
                    A = vstack([x_coords,ones(len(x_coords))]).T
                    m, b = lstsq(A, y_coords)[0]

                    # Calculating our new, and improved, xs
                    x1 = (min_y-b) / m
                    x2 = (max_y-b) / m

                    line_dict[idx] = [m,b,[int(x1), min_y, int(x2), max_y]]
                    new_lines.append([int(x1), min_y, int(x2), max_y])

            final_lanes = {}

            for idx in line_dict:
                final_lanes_copy = final_lanes.copy()
                m = line_dict[idx][0]
                b = line_dict[idx][1]
                line = line_dict[idx][2]
                
                if len(final_lanes) == 0:
                    final_lanes[m] = [ [m,b,line] ]
                    
                else:
                    found_copy = False

                    for other_ms in final_lanes_copy:

                        if not found_copy:
                            if abs(other_ms*1.2) > abs(m) > abs(other_ms*0.8):
                                if abs(final_lanes_copy[other_ms][0][1]*1.2) > abs(b) > abs(final_lanes_copy[other_ms][0][1]*0.8):
                                    final_lanes[other_ms].append([m,b,line])
                                    found_copy = True
                                    break
                            else:
                                final_lanes[m] = [ [m,b,line] ]

            line_counter = {}

            for lanes in final_lanes:
                line_counter[lanes] = len(final_lanes[lanes])

            top_lanes = sorted(line_counter.items(), key=lambda item: item[1])[::-1][:2]

            lane1_id = top_lanes[0][0]
            lane2_id = top_lanes[1][0]

            def average_lane(lane_data):
                x1s = []
                y1s = []
                x2s = []
                y2s = []
                for data in lane_data:
                    x1s.append(data[2][0])
                    y1s.append(data[2][1])
                    x2s.append(data[2][2])
                    y2s.append(data[2][3])
                return int(mean(x1s)), int(mean(y1s)), int(mean(x2s)), int(mean(y2s)) 

            l1_x1, l1_y1, l1_x2, l1_y2 = average_lane(final_lanes[lane1_id])
            l2_x1, l2_y1, l2_x2, l2_y2 = average_lane(final_lanes[lane2_id])

            return [l1_x1, l1_y1, l1_x2, l1_y2], [l2_x1, l2_y1, l2_x2, l2_y2]
        except Exception as e:
            print(str(e))


    def process_img(image):
        original_image = image
        # convert to gray
        processed_img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        # edge detection
        processed_img =  cv2.Canny(processed_img, threshold1 = 200, threshold2=300)
        
        processed_img = cv2.GaussianBlur(processed_img,(5,5),0)
        
        vertices = np.array([[10,500],[10,300],[300,200],[500,200],[800,300],[800,500],
                             ], np.int32)

        processed_img = roi(processed_img, [vertices])

        # more info: http://docs.opencv.org/3.0-beta/doc/py_tutorials/py_imgproc/py_houghlines/py_houghlines.html
        #                                     rho   theta   thresh  min length, max gap:        
        lines = cv2.HoughLinesP(processed_img, 1, np.pi/180, 180,      20,       15)
        try:
            l1, l2 = draw_lanes(original_image,lines)
            cv2.line(original_image, (l1[0], l1[1]), (l1[2], l1[3]), [0,255,0], 30)
            cv2.line(original_image, (l2[0], l2[1]), (l2[2], l2[3]), [0,255,0], 30)
        except Exception as e:
            print(str(e))
            pass
        try:
            for coords in lines:
                coords = coords[0]
                try:
                    cv2.line(processed_img, (coords[0], coords[1]), (coords[2], coords[3]), [255,0,0], 3)
                    
                    
                except Exception as e:
                    print(str(e))
        except Exception as e:
            pass

        return processed_img,original_image


    def run(self, data):
        if not data:
            return self.lastCmd
        #image = data['frame']
        #new_screen,original_image = process_img(image)
        #cv2.imshow('window', new_screen)
        #cv2.imshow('window2',cv2.cvtColor(original_image, cv2.COLOR_BGR2RGB))

        nextDest = gps.path[self.pathLoc]
        myLoc = GPS.totuple(data["location"])
        self.loc = myLoc

        if distance.euclidean(myLoc, nextDest) < 3:
            print("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n")
            self.pathLoc = self.pathLoc+1
            if self.pathLoc == len(gps.path):
                return [0.0, 0.0, 0.0]
            nextDest = gps.path[self.pathLoc]

        vehicleHeading = GPS.totuple(data["direction"])
        #print(vehicleHeading)
        goalDir = math.atan((myLoc[1] - nextDest[1])/(myLoc[0] - nextDest[0]))

        angledif = vehicleHeading-goalDir
        if angledif < -180 :
            angledif += 360
        elif angledif > 180:
            angledif-=360
        steeringVal = math.tanh(angledif / 25)

        if steeringVal < -1:
            steeringVal = -1
        elif steeringVal > 1:
            steeringVal = 1

        self.lastCmd=[0.5, 0.0, steeringVal]
        return self.lastCmd  # throttle, brake, steering


# Controls the DeepGTAV vehicle
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=None)
    parser.add_argument('-l', '--host', default='localhost', help='The IP where DeepGTAV is running')
    parser.add_argument('-p', '--port', default=8000, help='The port where DeepGTAV is running')

    args = parser.parse_args()
    print("Building GPS")
    gps = GPS.GPS()
    print("Finished building GPS")

     # Dummy agent
    model = Model(gps)

   # start = model.gps.closestNodeCoord((random.randint(-10000,10000), random.randint(-10000,10000), random.randint(-10000,10000)))
    #end = model.gps.closestNodeCoord((random.randint(-10000,10000), random.randint(-10000,10000), random.randint(-10000,10000)))
    start = model.gps.closestNodeCoord((-3000, 200, 0))
    end = model.gps.closestNodeCoord( (-3000, 1500, 0))
    print(start)
    model.gps.genPath(start, end)

    # Creates a new connection to DeepGTAV using the specified ip and port. 
    # If desired, a dataset path and compression level can be set to store in memory all the data received in a gziped pickle file.
    # We don't want to save a dataset in this case
    client = Client(ip=args.host, port=args.port)
    
    dataset = Dataset(rate=30, frame=[800,600], throttle=True, brake=True, steering=True, vehicles=False, peds=False, direction=[1, 1, 1], speed=True, yawRate=True, location=True, time=True)


    # We set the scenario to be in manual driving, and everything else random (time, weather and location). 
    # See deepgtav/messages.py to see what options are supported
    scenario = Scenario(drivingMode=-1, location=[start[0], start[1]], vehicle="blista") #manual driving
    
    # Send the Start request to DeepGTAV. Dataset is set as default, we only receive frames at 10Hz (320, 160)
    client.sendMessage(Start(dataset=dataset,scenario=scenario))
    
    # Start listening for messages coming from DeepGTAV. We do it for 80 hours
    stoptime = time.time() + 80*3600
    itt = 0.0
    while time.time() < stoptime:
        try:
            
            if 'Y' in key_check():
                client.sendMessage(Stop())
                client.sendMessage(Start(dataset=dataset,scenario=scenario))
            # We receive a message as a Python dictionary
            message = client.recvMessage()
            # The frame is a numpy array that can we pass through a CNN for example     
            #image = frame2numpy(message['frame'], (320,160))
            #cv2.imshow('img',image)
            #cv2.waitKey(-1)
            commands = model.run(message)
            print(commands)
            # We send the commands predicted by the agent back to DeepGTAV to control the vehicle
            client.sendMessage(Commands(commands[0], commands[1], commands[2]))
        except KeyboardInterrupt:
            client.sendMessage(Stop())
            client.close()
            break
            
    # We tell DeepGTAV to stop
    client.sendMessage(Stop())
    client.close()
